use crate::mir::{MIRStatement, MIRVariable};
use std::borrow::Cow;
use std::collections::HashMap;
use std::marker::PhantomData;
use std::mem::swap;

/// Explores every statement in a block,
/// running the specified function alongside
/// a scope representing which variables
/// are available.
/// This also runs on_scope_drop for every variable
/// that is AUTOMATICALLY DROPPED.
/// Note that this does not include manual
/// drops.
/// However, manual drops are taken into consideration
/// in the scope.
///
/// The scope is updated AFTER the for_each, not before it.
///
/// for_each and on_scope_drop run statements inside a scope
/// first, before running the statement that contains the
/// scope.
/// scope_data runs the statement containing the scope BEFORE
/// running the statements inside the scope.
/// This allows data to be modified in scope_data, processed
/// by for_each, and optionally removed in for_each.
///
/// Returns whether exploration was successful.
/// Both functions return whether they were successful,
/// and will halt exploration if any returns false.
pub struct StatementExplorer<Data: Clone + Default = ()> {
    _data: PhantomData<Data>,
}

/// A scope containing currently
/// available variables.
#[derive(Debug, Default)]
pub struct Scope<'a, Data: Clone + Default = ()> {
    /// The variables currently in scope.
    /// If shadowing occurs, a variable will
    /// be overridden.
    variables: HashMap<Cow<'a, str>, MIRVariable<'a>>,

    /// The variables that will be dropped at the end
    /// of this scope.
    /// This is in reverse drop order (i.e., the first
    /// item should be dropped last).
    /// If shadowing occurs, a variable will
    /// appear twice.
    /// This means deduplication MUST happen
    /// before drop analysis.
    to_drop: Vec<MIRVariable<'a>>,

    /// Data generated by the parent of this
    /// scope.
    pub parent_data: Data,
}

impl<'a, Data: Clone + Default> Scope<'a, Data> {
    /// Creates a new scope to be used
    /// in a sub block of the parent
    /// scope.
    pub fn child(&self) -> Self {
        Self {
            variables: self.variables.clone(),
            // The parent's variables shouldn't
            // be dropped at the end of this
            // scope.
            to_drop: vec![],
            parent_data: self.parent_data.clone(),
        }
    }

    /// Tries to look up a variable in the scope.
    pub fn get_variable(&self, name: &Cow<'a, str>) -> Option<&MIRVariable<'a>> {
        self.variables.get(name)
    }

    /// Returns an iterator representing the
    /// variables that are automatically dropped
    /// in this scope, in the order that they
    /// should be dropped in.
    ///
    /// Variables that are manually dropped won't
    /// be included.
    pub fn auto_drops(&self) -> impl Iterator<Item = &MIRVariable<'a>> {
        self.to_drop.iter().rev()
    }
}

macro_rules! explore_recurse {
    ($statement:expr, ($list:ident) => $recurse:block) => {
        match $statement {
            // Doesn't include sub blocks.
            MIRStatement::SetVariable { .. } => {}
            MIRStatement::Goto { .. } => {}
            MIRStatement::Label { .. } => {}
            MIRStatement::CreateVariable(..) => {}
            MIRStatement::DropVariable(..) => {}
            MIRStatement::GotoNotEqual { .. } => {}
            MIRStatement::ContinueStatement { .. } => {}
            MIRStatement::BreakStatement { .. } => {}

            MIRStatement::LoopStatement { body, .. } => {
                let $list = body;
                { $recurse }
            }
            MIRStatement::IfStatement {
                on_true, on_false, ..
            } => {
                let $list = on_true;
                {
                    $recurse
                }

                let $list = on_false;
                { $recurse }
            }
        }
    };
}

impl<Data: Clone + Default> StatementExplorer<Data> {
    /// Explores every statement in a block.
    pub fn explore_block<'a>(
        block: &[MIRStatement<'a>],
        for_each: &impl Fn(&MIRStatement<'a>, &Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        scope_data: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
    ) -> bool {
        Self::explore_block_internal(
            block,
            for_each,
            on_scope_drop,
            scope_data,
            &Scope::default(),
        )
    }

    fn explore_block_internal<'a>(
        block: &[MIRStatement<'a>],
        for_each: &impl Fn(&MIRStatement<'a>, &Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        scope_data: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        parent_scope: &Scope<'a, Data>,
    ) -> bool {
        let mut scope = parent_scope.child();

        for statement in block {
            scope_data(statement, &mut scope);

            explore_recurse!(statement, (block) => {
                if !Self::explore_block_internal(block, for_each, on_scope_drop, scope_data, &scope) {
                    return false;
                }
            });

            if !for_each(statement, &scope) {
                return false;
            }

            if !Self::explore_block_handle_scope(statement, &mut scope) {
                return false;
            }
        }

        Self::explore_block_handle_drop(&scope, on_scope_drop);

        true
    }

    fn explore_block_handle_scope<'a>(
        statement: &MIRStatement<'a>,
        scope: &mut Scope<'a, Data>,
    ) -> bool {
        match statement {
            // Doesn't create / drop variables.
            MIRStatement::SetVariable { .. } => {}
            MIRStatement::IfStatement { .. } => {}
            MIRStatement::Goto { .. } => {}
            MIRStatement::Label { .. } => {}
            MIRStatement::GotoNotEqual { .. } => {}
            MIRStatement::ContinueStatement { .. } => {}
            MIRStatement::BreakStatement { .. } => {}
            MIRStatement::LoopStatement { .. } => {}

            MIRStatement::CreateVariable(var, ..) => {
                scope.variables.insert(var.name.clone(), var.clone());
                scope.to_drop.push(var.clone());
            }
            MIRStatement::DropVariable(name, ..) => {
                // Manual drops don't invoke on_scope_drop.

                if scope.variables.remove(name).is_none() {
                    eprintln!("Failed to drop {name}: variable does not exist!");
                    return false;
                }

                // We already dropped it, so no
                // need to do it automatically.
                scope.to_drop.retain(|var| &var.name != name);
            }
        }

        true
    }

    fn explore_block_handle_drop<'a>(
        scope: &Scope<'a, Data>,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
    ) {
        // Drop at the end of scope.
        // This needs to be in reverse
        // order because the to_drop list
        // is constructed in reverse drop
        // order.
        for var in scope.to_drop.iter().rev() {
            on_scope_drop(var, &scope);
        }
    }

    /// This is a version of explore_block
    /// that allows modifying each statement.
    pub fn explore_block_mut<'a>(
        block: &mut [MIRStatement<'a>],
        for_each: &impl Fn(&mut MIRStatement<'a>, &Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        scope_data: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
    ) -> bool {
        Self::explore_block_mut_internal(
            block,
            for_each,
            on_scope_drop,
            scope_data,
            &Scope::default(),
        )
    }

    fn explore_block_mut_internal<'a>(
        block: &mut [MIRStatement<'a>],
        for_each: &impl Fn(&mut MIRStatement<'a>, &Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        scope_data: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        parent_scope: &Scope<'a, Data>,
    ) -> bool {
        let mut scope = parent_scope.child();

        for statement in block {
            scope_data(statement, &mut scope);

            explore_recurse!(statement, (block) => {
                if !Self::explore_block_mut_internal(block, for_each, on_scope_drop, scope_data, &scope) {
                    return false;
                }
            });

            if !for_each(statement, &scope) {
                return false;
            }

            if !Self::explore_block_handle_scope(statement, &mut scope) {
                return false;
            }
        }

        Self::explore_block_handle_drop(&scope, on_scope_drop);

        true
    }

    /// Rewrites a block, allowing for arbitrary
    /// insertion before and after each statement.
    /// The push function must be used inside for_each,
    /// or else all statements will be deleted.
    ///
    /// This includes a scope representing which variables
    /// are available.
    /// This also runs on_scope_drop for every variable
    /// that is AUTOMATICALLY DROPPED.
    /// Note that this does not include manual
    /// drops.
    /// However, manual drops are taken into consideration
    /// in the scope.
    ///
    /// The scope is updated AFTER the for_each, not before it.
    ///
    /// Returns whether rewriting was successful.
    /// Both functions return whether they were successful,
    /// and will halt exploration if either returns false.
    pub fn rewrite_block<'a>(
        block: &mut Vec<MIRStatement<'a>>,
        for_each: &mut impl FnMut(
            MIRStatement<'a>,
            &Scope<'a, Data>,
            &mut Vec<MIRStatement<'a>>,
        ) -> bool,
        on_scope_end: &mut impl FnMut(&Scope<'a, Data>, &mut Vec<MIRStatement<'a>>) -> bool,
        scope_data: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
    ) -> bool {
        Self::rewrite_block_internal(block, for_each, on_scope_end, scope_data, &Scope::default())
    }

    fn rewrite_block_internal<'a>(
        block: &mut Vec<MIRStatement<'a>>,
        for_each: &mut impl FnMut(
            MIRStatement<'a>,
            &Scope<'a, Data>,
            &mut Vec<MIRStatement<'a>>,
        ) -> bool,
        on_scope_end: &mut impl FnMut(&Scope<'a, Data>, &mut Vec<MIRStatement<'a>>) -> bool,
        scope_data: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        parent_scope: &Scope<'a, Data>,
    ) -> bool {
        let mut scope = parent_scope.child();

        let mut old_block = vec![];
        swap(block, &mut old_block);

        for mut statement in old_block {
            scope_data(&statement, &mut scope);

            explore_recurse!(&mut statement, (block) => {
                if !Self::rewrite_block_internal(block, for_each, on_scope_end, scope_data, &scope) {
                    return false;
                }
            });

            if !for_each(statement.clone(), &scope, block) {
                return false;
            }

            if !Self::explore_block_handle_scope(&statement, &mut scope) {
                return false;
            }
        }

        if !on_scope_end(&scope, block) {
            return false;
        }

        true
    }
}
