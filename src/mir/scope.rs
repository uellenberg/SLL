use crate::mir::{MIRStatement, MIRVariable};
use std::borrow::Cow;
use std::collections::HashMap;
use std::marker::PhantomData;
use std::mem::swap;

/// Explores every statement in a block,
/// running the specified function alongside
/// a scope representing which variables
/// are available.
/// This also runs on_scope_drop for every variable
/// that is AUTOMATICALLY DROPPED.
/// Note that this does not include manual
/// drops.
/// However, manual drops are taken into consideration
/// in the scope.
///
/// The scope is updated AFTER the for_each, not before it.
///
/// for_each and on_scope_drop run statements inside a scope
/// first, before running the statement that contains the
/// scope.
/// pre_run runs the statement containing the scope BEFORE
/// running the statements inside the scope.
/// This allows data to be modified in pre_run, processed
/// by for_each, and optionally removed in for_each.
///
/// Returns whether exploration was successful.
/// Both functions return whether they were successful,
/// and will halt exploration if any returns false.
pub struct StatementExplorer<Data: Clone + Default = ()> {
    _data: PhantomData<Data>,
}

/// A scope containing currently
/// available variables.
#[derive(Debug, Default)]
pub struct Scope<'a, Data: Clone + Default = ()> {
    /// The variables currently in scope.
    /// If shadowing occurs, a variable will
    /// be overridden.
    variables: HashMap<Cow<'a, str>, MIRVariable<'a>>,

    /// The variables that will be dropped at the end
    /// of this scope.
    /// This is in reverse drop order (i.e., the first
    /// item should be dropped last).
    /// If shadowing occurs, a variable will
    /// appear twice.
    /// This means deduplication MUST happen
    /// before drop analysis.
    to_drop: Vec<MIRVariable<'a>>,

    /// Data generated by the parent of this
    /// scope.
    ///
    /// When this data is modified, it gets
    /// propagated to children.
    /// However, children modifying this data
    /// won't propagate it to the parent.
    ///
    /// In addition, modifications to this data
    /// won't affect statements on the same scope,
    /// only those that are a child of the one modifying
    /// this data.
    ///
    /// However, parent_data is retained from pre_run
    /// to for_each, and can be used to share data between
    /// the two phases.
    pub parent_data: Data,
}

impl<'a, Data: Clone + Default> Scope<'a, Data> {
    /// Creates a new scope to be used
    /// in a sub block of the parent
    /// scope.
    pub fn child(&self) -> Self {
        Self {
            variables: self.variables.clone(),
            // The parent's variables shouldn't
            // be dropped at the end of this
            // scope.
            to_drop: vec![],
            parent_data: self.parent_data.clone(),
        }
    }

    /// Tries to look up a variable in the scope.
    pub fn get_variable(&self, name: &Cow<'a, str>) -> Option<&MIRVariable<'a>> {
        self.variables.get(name)
    }

    /// Returns an iterator representing the
    /// variables that are automatically dropped
    /// in this scope, in the order that they
    /// should be dropped in.
    ///
    /// Variables that are manually dropped won't
    /// be included.
    pub fn auto_drops(&self) -> impl Iterator<Item = &MIRVariable<'a>> {
        self.to_drop.iter().rev()
    }
}

macro_rules! explore_recurse {
    ($statement:expr, ($list:ident) => $recurse:block) => {
        match $statement {
            // Doesn't include sub blocks.
            MIRStatement::SetVariable { .. } => {}
            MIRStatement::Goto { .. } => {}
            MIRStatement::Label { .. } => {}
            MIRStatement::CreateVariable(..) => {}
            MIRStatement::DropVariable(..) => {}
            MIRStatement::GotoNotEqual { .. } => {}
            MIRStatement::ContinueStatement { .. } => {}
            MIRStatement::BreakStatement { .. } => {}

            MIRStatement::LoopStatement { body, .. } => {
                let $list = body;
                { $recurse }
            }
            MIRStatement::IfStatement {
                on_true, on_false, ..
            } => {
                let $list = on_true;
                {
                    $recurse
                }

                let $list = on_false;
                { $recurse }
            }
        }
    };
}

impl<Data: Clone + Default> StatementExplorer<Data> {
    /// Explores every statement in a block.
    pub fn explore_block<'a>(
        block: &[MIRStatement<'a>],
        for_each: &impl Fn(&MIRStatement<'a>, &Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        pre_run: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
    ) -> bool {
        Self::explore_block_internal(block, for_each, on_scope_drop, pre_run, Scope::default())
    }

    fn explore_block_internal<'a>(
        block: &[MIRStatement<'a>],
        for_each: &impl Fn(&MIRStatement<'a>, &Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        pre_run: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        mut scope: Scope<'a, Data>,
    ) -> bool {
        for statement in block {
            // We need to do this so parent_data
            // is shared between pre_run and for_each.
            {
                let mut child_scope = scope.child();
                if !pre_run(&statement, &mut child_scope) {
                    return false;
                }

                explore_recurse!(statement, (child_block) => {
                    if !Self::explore_block_internal(child_block, for_each, on_scope_drop, pre_run, child_scope.child()) {
                        return false;
                    }
                });

                if !for_each(statement, &child_scope) {
                    return false;
                }
            }

            if !Self::explore_block_handle_scope(statement, &mut scope) {
                return false;
            }
        }

        Self::explore_block_handle_drop(&scope, on_scope_drop);

        true
    }

    fn explore_block_handle_scope<'a>(
        statement: &MIRStatement<'a>,
        scope: &mut Scope<'a, Data>,
    ) -> bool {
        match statement {
            // Doesn't create / drop variables.
            MIRStatement::SetVariable { .. } => {}
            MIRStatement::IfStatement { .. } => {}
            MIRStatement::Goto { .. } => {}
            MIRStatement::Label { .. } => {}
            MIRStatement::GotoNotEqual { .. } => {}
            MIRStatement::ContinueStatement { .. } => {}
            MIRStatement::BreakStatement { .. } => {}
            MIRStatement::LoopStatement { .. } => {}

            MIRStatement::CreateVariable(var, ..) => {
                scope.variables.insert(var.name.clone(), var.clone());
                scope.to_drop.push(var.clone());
            }
            MIRStatement::DropVariable(name, ..) => {
                // Manual drops don't invoke on_scope_drop.

                if scope.variables.remove(name).is_none() {
                    eprintln!("Failed to drop {name}: variable does not exist!");
                    return false;
                }

                // We already dropped it, so no
                // need to do it automatically.
                scope.to_drop.retain(|var| &var.name != name);
            }
        }

        true
    }

    fn explore_block_handle_drop<'a>(
        scope: &Scope<'a, Data>,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
    ) {
        // Drop at the end of scope.
        // This needs to be in reverse
        // order because the to_drop list
        // is constructed in reverse drop
        // order.
        for var in scope.to_drop.iter().rev() {
            on_scope_drop(var, &scope);
        }
    }

    /// This is a version of explore_block
    /// that allows modifying each statement.
    pub fn explore_block_mut<'a>(
        block: &mut [MIRStatement<'a>],
        for_each: &impl Fn(&mut MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        pre_run: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
    ) -> bool {
        Self::explore_block_mut_internal(block, for_each, on_scope_drop, pre_run, Scope::default())
    }

    fn explore_block_mut_internal<'a>(
        block: &mut [MIRStatement<'a>],
        for_each: &impl Fn(&mut MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        on_scope_drop: &impl Fn(&MIRVariable<'a>, &Scope<'a, Data>) -> bool,
        pre_run: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>) -> bool,
        mut scope: Scope<'a, Data>,
    ) -> bool {
        for statement in block {
            // We need to do this so parent_data
            // is shared between pre_run and for_each.
            {
                let mut child_scope = scope.child();
                if !pre_run(&statement, &mut child_scope) {
                    return false;
                }

                explore_recurse!(statement, (child_block) => {
                    if !Self::explore_block_mut_internal(child_block, for_each, on_scope_drop, pre_run, child_scope.child()) {
                        return false;
                    }
                });

                if !for_each(statement, &mut child_scope) {
                    return false;
                }
            }

            if !Self::explore_block_handle_scope(statement, &mut scope) {
                return false;
            }
        }

        Self::explore_block_handle_drop(&scope, on_scope_drop);

        true
    }

    /// Rewrites a block, allowing for arbitrary
    /// insertion before and after each statement.
    /// The push function must be used inside for_each,
    /// or else all statements will be deleted.
    ///
    /// pre_run allows inserting statements before
    /// running that statement's children.
    pub fn rewrite_block<'a>(
        block: &mut Vec<MIRStatement<'a>>,
        for_each: &mut impl FnMut(
            MIRStatement<'a>,
            &Scope<'a, Data>,
            &mut Vec<MIRStatement<'a>>,
        ) -> bool,
        on_scope_end: &mut impl FnMut(&Scope<'a, Data>, &mut Vec<MIRStatement<'a>>) -> bool,
        pre_run: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>, &mut Vec<MIRStatement<'a>>) -> bool,
    ) -> bool {
        Self::rewrite_block_internal(block, for_each, on_scope_end, pre_run, Scope::default())
    }

    fn rewrite_block_internal<'a>(
        block: &mut Vec<MIRStatement<'a>>,
        for_each: &mut impl FnMut(
            MIRStatement<'a>,
            &Scope<'a, Data>,
            &mut Vec<MIRStatement<'a>>,
        ) -> bool,
        on_scope_end: &mut impl FnMut(&Scope<'a, Data>, &mut Vec<MIRStatement<'a>>) -> bool,
        pre_run: &impl Fn(&MIRStatement<'a>, &mut Scope<'a, Data>, &mut Vec<MIRStatement<'a>>) -> bool,
        mut scope: Scope<'a, Data>,
    ) -> bool {
        let mut old_block = vec![];
        swap(block, &mut old_block);

        for mut statement in old_block {
            // We need to do this so parent_data
            // is shared between pre_run and for_each.
            {
                let mut child_scope = scope.child();
                if !pre_run(&statement, &mut child_scope, block) {
                    return false;
                }

                explore_recurse!(&mut statement, (child_block) => {
                    if !Self::rewrite_block_internal(child_block, for_each, on_scope_end, pre_run, child_scope.child()) {
                        return false;
                    }
                });

                if !for_each(statement.clone(), &mut child_scope, block) {
                    return false;
                }
            }

            if !Self::explore_block_handle_scope(&statement, &mut scope) {
                return false;
            }
        }

        if !on_scope_end(&scope, block) {
            return false;
        }

        true
    }
}
